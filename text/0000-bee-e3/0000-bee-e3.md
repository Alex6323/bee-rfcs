+ Feature Name: bee-e3
+ Start Date: 2019-09-05
+ RFC PR: [iotaledger/bee-rfcs#0000](https://github.com/iotaledger/bee-rfcs/pull/0000)
+ Bee issue: [iotaledger/bee#42](https://github.com/iotaledger/bee/issues/42)

# Summary

This feature introduces a *pub/sub messaging mechanism* for the Bee node framework that allows asynchronous communication across all node components without them being directly dependent on eachother, thereby allowing the system to become very modular and loosely coupled. It arrives as part of a dedicated crate named `bee-e3`, which will expand the current `bee` workspace.

This feature implements a subset of the **EEE** specification introduced by the IOTA Foundation. The following are the most relevant:

* **Effect**: effects represent the data that is sent between entities and environments. They abstract over the concrete data type used to encode a particular information. One can think of them as *messages*.
* **Environment**: environments are namespaces that can receive effects from "affecting" entities and forward them - unmodified - to entities that have "joined" one. However, environments must not communicate with other environments directly. The name of an environment *must* be unique and *should* be meaningful with the intent to best describe its purpose.
* **Entity**: entities are actors, that not only can receive/broadcast effects from/to one or many environments, but also mutate or even replace them by applying some custom logic defined by the programmer. However, entities must not communicate with other entities directly. Entities that haven't joined an environment, but are affecting at least one can be thought of as *source entities*, while those that have joined environments, but are not affecting any can be thought of as *sink entities*. They are the entry and the exit points to the messaging system. That for example will allow for Bee to send gossip utilizing several different network protocols, which is a necessity in the IoT.

# Motivation

This messaging system will bring the following benefits:
* the node framework becomes highly decoupled by preventing entities from interacting directly with eachother, but instead having them to publish their results via an environment, which in turn arbitrary many entities can subscribe to without the entity even noticing or caring.
* the node framework overall becomes more resilient to partial system failures due to the fact that is based on a pub/sub model, where subscribers only react to something being published they don't require to have control over.
* the node framework becomes more easily extendable. That also comes from the fact that it is based on a pub/sub model. Arbitrary many entities can subscribe to an environment, without any additional effort to support that.

# Detailed design

This crate will be implemented using asynchronous programming patterns similar to how it was previously done in https://github.com/Alex6323/reee.git. This means that all created environments and entities in the system are implemented as futures or streams of futures, that can potentially run concurrently depending on the underlying hardware. However, there will be significant changes to how the API will look like.

## Example 
Imagine implementing a live TPS calculator for a bee calculating a 1 minute moving average every second. With the `bee-e3` crate this could be achieved like so: 

1. Create a struct `Tps`.
2. Implement the `e3::Entity` trait for `Tps`, which requires you to implement a method `process`. Depending on the internal state of `Tps` it has to produce a new effect from the received one.
3. Register the entity with the messaging system. `bee-e3` will spawn it as a stream of futures onto its internal runtime and execute it asynchronously.
4. Make the entity listen on environment "GOSSIP_IN_SIGNAL", that is assumed to be introduced by some other crate, e.g. `bee-gossip`.
5. Create a new environment "TPS_IN".
6. Let this new environment subscribe to our entity, which means that the output of our entity will be sent to it.
   
What happens when running that bee is that the environment "GOSSIP_IN_SIGNAL" will forward `Effect::Signal` to all of its subscribers each time a transaction arrives at some source entity informing that environment about it by sending that effect to it. From that (and some internal timer) the entity can now produce an `Effect::Float64(tps)` every second and `bee-e3` will take care of sending it to another environment we call "TPS_IN", that now other entities like some Terminal UI or later some Web UI can be subscribed to to display that information to the node owner. 

Let's look at some example code:

```Rust
use e3::{self, Effect, Entity};

struct Tps {
    num_gossip_events: u64,
    ...
}

impl Tps {...}

impl Entity for Tps {
    fn process(&mut self, effect: Effect, environment_name: &str) -> Effect {
        //match on 'effect' and increase/reset counter appropriately
    }
}

pub fn init() {

    // Our entity is registered and an id (UUID) will be returned so we can refer to it.
    let calc_tps = e3::register_entity(Tps::new());

    // We assume that somewhere else in the system an environment named "GOSSIP_IN_SIGNAL" 
    // exists. But if it doesn't, then this shouldn't cause the node to panic and go down.
    // All that would happen in this specific case is that our calculator wouldn't get any 
    // input signals.
    e3::subscribe_environment(&calc_tps, "GOSSIP_IN_SIGNAL");

    // Sometimes - like in this case - a crate introduces a new environment, that other 
    // parts of the system can subscribe to without having to link the particular crate 
    // that introduced it. 
    let tps_in = e3::create_environment("TPS_IN");

    // This new environment will itself subscribe to our entity "Tps", or in EEE 
    // terms this entity will now affect environment "TPS_IN".
    e3::subscribe_entity(&tps_in, &calc_tps); 
}

```

That's basically all you have to do to hook into the messaging system. Notice how our 
`Tps` entity cannot "see" beyond the environments "GOSSIP_IN_SIGNAL" and "TPS_IN" that it interacts with. It does its job when it receives something, knows where to send its finished work, but doesn't know or care about anything else. If no input signals arrive for a while, it just stays silent, and continues its work once normal operation is restored.

The `bee-e3` messaging system itself is initialized in `bee-main` alongside the Bee node, and will probably consist of the calls:
```Rust
fn main() {
   e3::init(); // initialize runtime and task executor for EEE
   ...
   e3::shutdown(); // gracefully shutdown all asynchronous tasks related to EEE
}
```

# Drawbacks

The cost of this is efficiency - both memory- and processorwise - mainly due to the following attributes of such a messaging system:
* *message passing*: It is not clear at the moment to what extent this will be a problem, but considering that a constant stream of gossip and other data needs to be processed at a very high rate, redundant copying of data could lead to a sub-optimal performance of the node, and should in general be reduced to a minimum.
* *message indirection*: Since data is not sent directly to entities that are acting on it, but only indirectly via an environment which additionally treats all subscribers equally, there can be some overhead expected compared to a system, that processes all steps different entities do directly one after another.

# Rationale and alternatives

One of the main priorities for Bee as a framework of nodes (among safety and performance) is *modularity*. This comes from two facts: First, a node assembled by it is intended to operate in an already very diverse environment consisting of many different types of devices ranging from tiny wearables to powerful server farms utilizing data exchange protocols optimized for their respective environments. And this can only be expected to increase even more in the future. Second, to accomodate for the fact, that the whole DLT space is still pretty much in research phase and new developments can happen any day, that need to be integrated quickly in already existing node software. This messaging protocol could allow for such kind of modularity. The performance drawbacks might not be noticeable, because other bottlenecks like bandwidth might kick in long before those things become real issues. Using an EEE based messaging protocol instead of other pub/sub methods has the advantage of having absolute control over the design. Also it is doesn't introduce additional dependencies in a security-critical application and features this node doesn't necessarily need.

If we decide to not use it, then we would probably need to make more `bee-`crates dependent on eachother, thereby breaking their encapsulation and reducing modularity when there could have been an alternative protocol to support that. Resorting to 3rd party libraries that provide similar functionality would negate the aforementioned advantages of not using those.

# Unresolved questions

- What parts of the design do you expect to resolve through the RFC process before this gets merged?
    * I want to hear people's thoughts and opinions about this proposal. Who sees value in this actually being implemented in a node software. Or will such a system be too inefficient?

- What parts of the design do you expect to resolve through the implementation
  of this feature before stabilization?
    * I want to know if this system can be efficiently implemented using  `async-std`.
